import crypto from 'crypto'

export interface TeeQuote {
    quote: string
    signature: string
    timestamp: number
    mrEnclave: string // Measurement of the enclave code
}

export class AttestationService {
    private readonly isSimulated: boolean
    private readonly teeSecretKey: string // In real TEE, this is derived from hardware root of trust

    constructor() {
        // Check if running in a real TEE environment (e.g. Gramine/Occlum)
        // For now, we simulate it.
        this.isSimulated = process.env.TEE_SIMULATION !== 'false'
        this.teeSecretKey = process.env.TEE_SECRET_KEY || 'mock-tee-secret-key-do-not-use-in-prod'

        if (this.isSimulated) {
            console.warn('‚ö†Ô∏è  Running in TEE SIMULATION mode. Attestations are NOT secure.')
        } else {
            console.log('üîí  Initializing Real TEE Attestation Service...')
        }
    }

    /**
     * Generates a "Consent-to-Spend" quote.
     * In a real SGX enclave, this would call the architectural enclave (QE).
     * Here, we sign the payload with our mock key.
     */
    async generateQuote(payload: string): Promise<TeeQuote> {
        const timestamp = Date.now()
        const dataToSign = `${payload}:${timestamp}`

        // Simulate signing
        const signature = crypto
            .createHmac('sha256', this.teeSecretKey)
            .update(dataToSign)
            .digest('hex')

        // Simulate MR_ENCLAVE (a hash of the code)
        const mrEnclave = '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef'

        if (this.isSimulated) {
            return {
                quote: `MOCK_QUOTE_FOR:${payload}`,
                signature,
                timestamp,
                mrEnclave
            }
        }

        // Real SGX Implementation (Gramine/Occlum)
        try {
            // In Gramine, the quote is often generated by writing to a device file or reading from one.
            // For this implementation, we will assume a standard local attestation flow via fs.
            // Note: This requires the container to have /dev/attestation mounted.
            const fs = require('fs');
            if (fs.existsSync('/dev/attestation/user_report_data')) {
                // write report data (hash of payload)
                const reportData = crypto.createHash('sha256').update(payload).digest();
                fs.writeFileSync('/dev/attestation/user_report_data', reportData);

                // read quote
                const quoteBuffer = fs.readFileSync('/dev/attestation/quote');
                return {
                    quote: quoteBuffer.toString('base64'),
                    signature: 'SGX_SIGNED', // The signature is embedded in the quote
                    timestamp,
                    mrEnclave: 'REAL_SGX_HARDWARE'
                };
            }
        } catch (e) {
            console.error('[TEE] Failed to generate real quote:', e);
        }

        // Fallback if device not found
        return {
            quote: `FALLBACK_QUOTE:${payload}`,
            signature,
            timestamp,
            mrEnclave
        }
    }

    /**
     * Verifies a quote.
     * In production, this runs on-chain or via a remote verifier (Intel IAS/DCAP).
     */
    async verifyQuote(quote: TeeQuote, originalPayload: string): Promise<boolean> {
        const dataToSign = `${originalPayload}:${quote.timestamp}`
        const expectedSignature = crypto
            .createHmac('sha256', this.teeSecretKey)
            .update(dataToSign)
            .digest('hex')

        if (quote.signature !== expectedSignature) return false

        // Check timestamp freshness (e.g. 5 mins)
        if (Date.now() - quote.timestamp > 300000) return false

        return true
    }
}
